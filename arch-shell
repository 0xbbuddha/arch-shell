#!/bin/bash

# =============================================
# Script: arch-shell
# Description: Arch Linux environment management
# Author: Killian Prin-abeil <killian@archimedeos.org>
# Date: $(date +%Y-%m-%d)
# =============================================

set -euo pipefail

DEBUG=false
NO_COLOR=false
YES=false
QUIET=false
ARCHSHELL_DIR="${HOME}/.arch-shell"
ARCHSHELL_ENVS="${ARCHSHELL_DIR}/envs"
ARCHSHELL_STORE="${ARCHSHELL_DIR}/store"
BASE_TEMPLATE="${ARCHSHELL_STORE}/base-template"
SHARED_CACHE="${ARCHSHELL_DIR}/cache"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

init_colors() {
    if [ "$NO_COLOR" = true ]; then
        RED=''
        GREEN=''
        YELLOW=''
        BLUE=''
        NC=''
    fi
}

ask_confirmation() {
    local prompt="$1"
    local default="${2:-N}"
    
    if [ "$YES" = true ]; then
        echo -e "${GREEN}[*] ${prompt} [AUTO-YES]${NC}"
        return 0
    fi
    
    read -p "$prompt" -r
    if [[ $REPLY =~ ^[oOyY]$ ]]; then
        return 0
    else
        return 1
    fi
}

quiet_log() {
    if [ "$QUIET" != true ]; then
        echo -e "$@"
    fi
}

error_log() {
    echo -e "$@" >&2
}

spinner() {
  local pid=$1
  local msg="$2"
  local spinstr='|/-\\'
  local i=0
  
  if [ "$QUIET" = true ]; then
    wait $pid
    return
  fi
  
  tput civis
  while kill -0 $pid 2>/dev/null; do
    i=$(( (i+1) %4 ))
    printf "\r${YELLOW}[*] %s %s${NC}" "${spinstr:$i:1}" "$msg"
    sleep 0.1
  done
  printf "\r${GREEN}[*] %s completed!${NC}\n" "$msg"
  tput cnorm
}

debug_log() {
    if [ "$DEBUG" = true ]; then
        echo -e "${BLUE}[DEBUG]${NC} $*" >&2
    fi
}

debug_run() {
    local cmd="$*"
    debug_log "Execution: $cmd"
    
    if [ "$DEBUG" = true ]; then
        eval "$cmd"
        return $?
    else
        eval "$cmd" > /dev/null 2>&1
        return $?
    fi
}

usage() {
    echo "Usage: $0 [--debug] [--no-color] [--yes] [--quiet] <command> [options]"
    echo ""
    echo "Global options:"
    echo "  --debug             Show commands and outputs in real time"
    echo "  --no-color          Disable colors in output"
    echo "  --yes               Automatically answer 'yes' to confirmations"
    echo "  --quiet             Show only errors"
    echo ""
    echo "Commands:"
    echo "  init                Initialize arch-shell"
    echo "  regen-base          Regenerate base template"
    echo "  create <env>        Create a new environment"
    echo "  -S <env> <pkg...>   Install packages in an environment"
    echo "  -R <env> <pkg...>   Remove packages from an environment"
    echo "  enter <env>         Enter an environment"
    echo "  delete <env>        Delete an environment"
    echo "  list                List all environments"
    echo "  info <env>          Show environment information"
    echo "  export <env> <file> Export an environment"
    echo "  import <file> <env> Import an environment"
    echo "  run <env> <command> Execute a command in an environment"
    echo "  clean <env>         Clean an environment"
    echo "  snapshot <env>      Manage environment snapshots"
    echo "  cache <options>     Interact with shared cache"
    echo "  copy <src> <dest>   Copy files between local and environment"
    exit 1
}

usage_run() {
    echo "Usage: $0 run <env> <command> [options]"
    echo ""
    echo "Execute a command or script in an environment."
    echo ""
    echo "Options:"
    echo "  --script <file>     Execute a script in the environment"
    echo "  --env <VAR=value>   Set an environment variable"
    echo ""
    echo "Examples:"
    echo "  $0 run my-env \"ls -la\""
    echo "  $0 run my-env \"make clean && make\""
    echo "  $0 run my-env --script build.sh"
    echo "  $0 run my-env --env DEBUG=1 \"./my-program\""
    echo "  $0 run my-env --env BUILD_TYPE=release --script deploy.sh"
    exit 1
}

usage_snapshot() {
    echo "Usage: $0 snapshot <env> [name] | $0 snapshot <env> <option>"
    echo ""
    echo "Manages snapshots (backups) of an environment."
    echo ""
    echo "Options:"
    echo "  --list              List all snapshots of the environment"
    echo "  --restore <snap>    Restore a snapshot (by name or number)"
    echo "  --delete <snap>     Delete a snapshot (by name)"
    echo ""
    echo "Examples:"
    echo "  $0 snapshot my-env                        Create snapshot with automatic name"
    echo "  $0 snapshot my-env \"before-test\"          Create named snapshot"
    echo "  $0 snapshot my-env --list                 List snapshots"
    echo "  $0 snapshot my-env --restore \"before-test\" Restore by name"
    echo "  $0 snapshot my-env --restore 1            Restore by number"
    echo "  $0 snapshot my-env --delete \"before-test\"  Delete snapshot"
    exit 1
}

usage_clean() {
    echo "Usage: $0 clean <env> [options]"
    echo ""
    echo "Cleans temporary files and caches of an environment."
    echo ""
    echo "Options:"
    echo "  --cache             Clean only pacman caches"
    echo "  --logs              Clean only system logs"
    echo "  --tmp               Clean only temporary files"
    echo "  --all               Clean everything (cache + logs + tmp)"
    echo "  --dry-run           Show what would be cleaned without doing it"
    echo "  --all-envs          Clean all environments"
    echo ""
    echo "Examples:"
    echo "  $0 clean my-env                Standard cleanup (cache + tmp)"
    echo "  $0 clean my-env --all          Full cleanup"
    echo "  $0 clean my-env --dry-run      Preview cleanup"
    echo "  $0 clean my-env --cache        Only caches"
    echo "  $0 clean --all-envs             Clean all environments"
    echo "  $0 clean --all-envs --dry-run  Preview for all environments"
    exit 1
}

usage_cache() {
    echo "Usage: $0 cache [options]"
    echo ""
    echo "Allows management of the shared arch-shell cache."
    echo ""
    echo "Options:"
    echo "  --stats             Show cache statistics"
    echo "  --list              List packages in cache"
    echo "  --clean             Clean cache"
    exit 1
}

usage_copy() {
    echo "Usage: $0 copy <source> <destination>"
    echo ""
    echo "Copy files between local system and environment."
    echo ""
    echo "Syntax:"
    echo "  <env>:<path>        File or directory in environment"
    echo "  <path>              File or directory on local system"
    echo ""
    echo "Options:"
    echo "  -r, --recursive     Copy directories recursively"
    echo ""
    echo "Examples:"
    echo "  $0 copy my-env:/etc/hosts ./hosts           Copy from env to local"
    echo "  $0 copy ./script.sh my-env:/root/script.sh  Copy from local to env"
    echo "  $0 copy -r ./mydir my-env:/root/mydir       Copy directory to env"
    echo "  $0 copy -r my-env:/var/log ./logs           Copy directory from env"
    exit 1
}

init_shared_cache() {
    debug_log "Initializing shared cache in $SHARED_CACHE"
    mkdir -p "$SHARED_CACHE/pkg"
    mkdir -p "$SHARED_CACHE/db"
    
    local stats_file="$SHARED_CACHE/cache-stats.json"
    if [ ! -f "$stats_file" ]; then
        cat > "$stats_file" << EOF
{
  "created": "$(date -Iseconds)",
  "total_downloads": 0,
  "cache_hits": 0,
  "total_size": 0,
  "packages_count": 0,
  "last_updated": "$(date -Iseconds)"
}
EOF
        debug_log "Cache statistics file created"
    fi
}

update_cache_stats() {
    local stats_file="$SHARED_CACHE/cache-stats.json"
    local pkg_count=$(find "$SHARED_CACHE/pkg" -name "*.pkg.tar.*" 2>/dev/null | wc -l || echo "0")
    local total_size=$(du -sb "$SHARED_CACHE/pkg" 2>/dev/null | awk '{print $1}' || echo "0")
    
    if [ -f "$stats_file" ] && command -v jq >/dev/null 2>&1; then
        jq ".packages_count = $pkg_count | .total_size = $total_size | .last_updated = \"$(date -Iseconds)\"" "$stats_file" > "${stats_file}.tmp" && mv "${stats_file}.tmp" "$stats_file"
    fi
}

track_cache_hit() {
    local pkg="$1"
    local stats_file="$SHARED_CACHE/cache-stats.json"
    
    if find "$SHARED_CACHE/pkg" -name "${pkg}-*.pkg.tar.*" -type f 2>/dev/null | head -1 | grep -q .; then
        echo -e "${GREEN}[*] Cache hit for ${pkg}${NC}"
        
        if [ -f "$stats_file" ] && command -v jq >/dev/null 2>&1; then
            local hits=$(jq -r '.cache_hits // 0' "$stats_file" 2>/dev/null || echo "0")
            if [ "$hits" != "null" ] && [ -n "$hits" ]; then
                jq ".cache_hits = $((hits + 1))" "$stats_file" > "${stats_file}.tmp" && mv "${stats_file}.tmp" "$stats_file" 2>/dev/null || true
            fi
        fi
        return 0
    fi
    return 1
}

track_download() {
    local stats_file="$SHARED_CACHE/cache-stats.json"
    local packages_count="$1"
    
    if [ -f "$stats_file" ] && command -v jq >/dev/null 2>&1; then
        local downloads=$(jq -r '.total_downloads // 0' "$stats_file" 2>/dev/null || echo "0")
        if [ "$downloads" != "null" ] && [ -n "$downloads" ]; then
            jq ".total_downloads = $((downloads + packages_count))" "$stats_file" > "${stats_file}.tmp" && mv "${stats_file}.tmp" "$stats_file" 2>/dev/null || true
        fi
    fi
}

show_cache_stats() {
    local stats_file="$SHARED_CACHE/cache-stats.json"
    local cache_size=$(du -sh "$SHARED_CACHE/pkg" 2>/dev/null | awk '{print $1}' || echo "0")
    local pkg_count=$(find "$SHARED_CACHE/pkg" -name "*.pkg.tar.*" 2>/dev/null | wc -l || echo "0")
    
    echo -e "${BLUE}[*] arch-shell shared cache statistics:${NC}"
    echo -e "${GREEN}  Packages in cache: ${pkg_count}${NC}"
    echo -e "${GREEN}  Cache size: ${cache_size}${NC}"
    
    if [ -f "$stats_file" ] && command -v jq >/dev/null 2>&1; then
        local hits=$(jq -r '.cache_hits // 0' "$stats_file" 2>/dev/null || echo "0")
        local downloads=$(jq -r '.total_downloads // 0' "$stats_file" 2>/dev/null || echo "0")
        local created=$(jq -r '.created // "N/A"' "$stats_file" 2>/dev/null || echo "N/A")
        
        echo -e "${GREEN}  Cache hits: ${hits}${NC}"
        echo -e "${GREEN}  Downloads: ${downloads}${NC}"
        echo -e "${GREEN}  Created: ${created}${NC}"
        
        if [ "$downloads" -gt 0 ]; then
            local hit_rate=$((hits * 100 / (hits + downloads)))
            echo -e "${GREEN}  Cache hit rate: ${hit_rate}%${NC}"
        fi
    fi
}

update_env_info() {
    local envname="$1"
    local envdir="${ARCHSHELL_ENVS}/${envname}"
    local infofile="${envdir}/.arch-shell-env"
    
    cat > "$infofile" << EOF
{
  "name": "$envname",
  "created": "$(date -Iseconds)",
  "last_used": "$(date -Iseconds)",
  "packages": [],
  "arch": "$(uname -m)"
}
EOF
}

update_last_used() {
    local envname="$1"
    local infofile="${ARCHSHELL_ENVS}/${envname}/.arch-shell-env"
    if [ -f "$infofile" ]; then
        if command -v jq >/dev/null 2>&1; then
            jq ".last_used = \"$(date -Iseconds)\"" "$infofile" > "${infofile}.tmp" && mv "${infofile}.tmp" "$infofile"
        else
            sed -i "s/\"last_used\": \"[^\"]*\"/\"last_used\": \"$(date -Iseconds)\"/" "$infofile"
        fi
    fi
}

add_package() {
    local envname="$1"
    local package="$2"
    local infofile="${ARCHSHELL_ENVS}/${envname}/.arch-shell-env"
    
    if [ -f "$infofile" ]; then
        if command -v jq >/dev/null 2>&1; then
            jq ".packages += [\"$package\"]" "$infofile" > "${infofile}.tmp" && mv "${infofile}.tmp" "$infofile"
        else
            sed -i "s/\"packages\": \[\([^]]*\)\]/\"packages\": [\1, \"$package\"]/" "$infofile"
        fi
    fi
}

remove_package() {
    local envname="$1"
    local package="$2"
    local infofile="${ARCHSHELL_ENVS}/${envname}/.arch-shell-env"
    
    if [ -f "$infofile" ]; then
        if command -v jq >/dev/null 2>&1; then
            jq ".packages -= [\"$package\"]" "$infofile" > "${infofile}.tmp" && mv "${infofile}.tmp" "$infofile"
        else
            sed -i "s/\"$package\",\?//g; s/,\s*]/]/g; s/\[,/[/g" "$infofile"
        fi
    fi
}

check_package_in_env() {
    local envname="$1"
    local package="$2"
    local infofile="${ARCHSHELL_ENVS}/${envname}/.arch-shell-env"
    
    if [ -f "$infofile" ]; then
        if command -v jq >/dev/null 2>&1; then
            jq -e ".packages | index(\"$package\")" "$infofile" >/dev/null 2>&1
        else
            grep -q "\"$package\"" "$infofile"
        fi
    else
        return 1
    fi
}

export_env() {
    local envname="$1"
    local export_file="$2"
    local envdir="${ARCHSHELL_ENVS}/${envname}"
    local infofile="${envdir}/.arch-shell-env"
    
    if [ ! -d "$envdir" ]; then
        echo -e "${RED}[!] Environment not found: ${envname}${NC}"
        return 1
    fi
    
    if [ ! -f "$infofile" ]; then
        echo -e "${RED}[!] Missing metadata file: ${infofile}${NC}"
        return 1
    fi
    
    if [ -d "$export_file" ]; then
        echo -e "${RED}[!] Export file cannot be a directory: ${export_file}${NC}"
        echo -e "${YELLOW}[?] Use a filename like: ${envname}-backup.tar.gz${NC}"
        return 1
    fi
    
    if [ -f "$export_file" ]; then
        echo -e "${YELLOW}[?] The file ${export_file} already exists${NC}"
        if ! ask_confirmation "Overwrite existing file? [o/N] "; then
            echo -e "${YELLOW}[!] Export cancelled${NC}"
            return 1
        fi
    fi
    
    export_file=$(realpath "$export_file" 2>/dev/null || echo "$export_file")
    
    local temp_dir
    temp_dir=$(mktemp -d)
    local export_dir="${temp_dir}/export"
    mkdir -p "$export_dir"
    
    echo -e "${BLUE}[*] Preparing export of ${envname}...${NC}"
    
    cat > "${envdir}/.arch-shell-export-metadata.json" << EOF
{
  "arch_shell_version": "$(grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+' "$0" 2>/dev/null || echo 'unknown')",
  "export_date": "$(date -Iseconds)",
  "environment_name": "$envname",
  "exported_by": "$(whoami)",
  "hostname": "$(hostname)",
  "arch": "$(uname -m)"
}
EOF
    
    local total_size
    total_size=$(sudo du -sb "$envdir" | awk '{print $1}')
    echo -e "${BLUE}[*] Creation of optimized archive ($(numfmt --to=iec $total_size))...${NC}"
    
    (
        cd "$envdir"
        debug_run "sudo tar --zstd -cf '$export_file' ."
    ) &
    spinner $! "Direct compression with zstd"
    
    rm -f "${envdir}/.arch-shell-export-metadata.json"
    
    local checksum
    checksum=$(sha256sum "$export_file" | awk '{print $1}')
    
    rm -rf "$temp_dir"
    
    quiet_log "${GREEN}[*] Export completed: ${export_file}${NC}"
    quiet_log "${GREEN}[*] Checksum SHA256 : ${checksum}${NC}"
    
    local archive_size
    archive_size=$(du -h "$export_file" | awk '{print $1}')
    quiet_log "${GREEN}[*] Archive size: ${archive_size}${NC}"
}

import_env() {
    local import_file="$1"
    local envname="$2"
    local envdir="${ARCHSHELL_ENVS}/${envname}"
    
    if [ ! -f "$import_file" ]; then
        echo -e "${RED}[!] Import file not found: ${import_file}${NC}"
        return 1
    fi
    
    if [ -d "$envdir" ]; then
        echo -e "${RED}[!] The environment ${envname} already exists${NC}"
        echo -e "${YELLOW}[?] Use .arch-shell delete ${envname}. to remove it first${NC}"
        return 1
    fi
    
    local temp_dir
    temp_dir=$(mktemp -d)
    
    echo -e "${BLUE}[*] Verifying and extracting optimized archive...${NC}"
    
    if tar --zstd -tf "$import_file" >/dev/null 2>&1; then
        echo -e "${BLUE}[*] zstd archive detected (optimized format)${NC}"
        
        mkdir -p "$envdir"
        (
            cd "$envdir"
            debug_run "sudo tar --zstd -xf '$import_file'"
        ) &
        spinner $! "Direct extraction with zstd"
        
        if [ -f "${envdir}/.arch-shell-export-metadata.json" ] && command -v jq >/dev/null 2>&1; then
            echo -e "${BLUE}[*] Archive information:${NC}"
            echo -e "${BLUE}    Archive:${NC} $(jq -r '.export_date' "${envdir}/.arch-shell-export-metadata.json" 2>/dev/null || echo 'unknown')"
            echo -e "${BLUE}    Environment:${NC} $(jq -r '.environment_name' "${envdir}/.arch-shell-export-metadata.json" 2>/dev/null || echo 'unknown')"
            echo -e "${BLUE}    Exported by:${NC} $(jq -r '.exported_by' "${envdir}/.arch-shell-export-metadata.json" 2>/dev/null || echo 'unknown')"
            rm -f "${envdir}/.arch-shell-export-metadata.json"
        fi
        
    else
        echo -e "${BLUE}[*] gzip archive detected (legacy format)${NC}"
        
        if ! tar xzf "$import_file" -C "$temp_dir" 2>/dev/null; then
            echo -e "${RED}[!] Error during archive extraction${NC}"
            rm -rf "$temp_dir"
            return 1
        fi
        
        local export_dir="${temp_dir}/export"
        if [ ! -d "$export_dir" ] || [ ! -f "${export_dir}/environment.tar.gz" ]; then
            echo -e "${RED}[!] Incomplete or corrupted archive${NC}"
            rm -rf "$temp_dir"
            return 1
        fi
        
        mkdir -p "$envdir"
        (
            cd "$envdir"
            gzip -dc "${export_dir}/environment.tar.gz" | sudo tar xf -
        ) &
        spinner $! "Environment extraction (legacy format)"
        
        if [ -f "${export_dir}/arch-shell-env.json" ]; then
            cp "${export_dir}/arch-shell-env.json" "${envdir}/.arch-shell-env"
        fi
    fi
    
    sudo chown -R $USER: "$envdir"
    update_last_used "$envname"
    rm -rf "$temp_dir"
    
    echo -e "${GREEN}[*] Import completed: environment ${envname} created${NC}"
}

clean_env() {
    local envname="$1"
    local clean_cache=false
    local clean_logs=false
    local clean_tmp=false
    local clean_all=false
    local dry_run=false
    local all_envs=false
    
    shift 1
    while [[ $# -gt 0 ]]; do
        case $1 in
            --cache)
                clean_cache=true
                shift
                ;;
            --logs)
                clean_logs=true
                shift
                ;;
            --tmp)
                clean_tmp=true
                shift
                ;;
            --all)
                clean_all=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --all-envs)
                all_envs=true
                shift
                ;;
            *)
                echo -e "${RED}[!] Unknown option: $1${NC}"
                return 1
                ;;
        esac
    done
    
    if [ "$clean_cache" = false ] && [ "$clean_logs" = false ] && [ "$clean_tmp" = false ] && [ "$clean_all" = false ]; then
        clean_cache=true
        clean_tmp=true
    fi
    
    if [ "$clean_all" = true ]; then
        clean_cache=true
        clean_logs=true
        clean_tmp=true
    fi
    
    clean_single_env() {
        local env="$1"
        local envdir="${ARCHSHELL_ENVS}/${env}"
        
        if [ ! -d "$envdir" ]; then
            echo -e "${RED}[!] Environnement inexistant : ${env}${NC}"
            return 1
        fi
        
        echo -e "${BLUE}[*] Cleaning environment ${env}...${NC}"
        
        local total_freed=0
        local files_removed=0
        
        if [ "$clean_cache" = true ]; then
            local cache_dir="${envdir}/var/cache/pacman/pkg"
            if [ -d "$cache_dir" ]; then
                local cache_size=$(sudo du -sb "$cache_dir" 2>/dev/null | awk '{print $1}' || echo "0")
                local cache_files=$(sudo find "$cache_dir" -name "*.pkg.tar.*" 2>/dev/null | wc -l || echo "0")
                
                if [ "$dry_run" = true ]; then
                    echo -e "${YELLOW}${YELLOW}[DRY-RUN] Pacman cache: ${NC} ${cache_files} fichiers ($(numfmt --to=iec $cache_size))${NC}"
                else
                    sudo find "$cache_dir" -name "*.pkg.tar.*" -delete 2>/dev/null
                    echo -e "${GREEN}[✓] Pacman cache cleaned: ${cache_files} fichiers ($(numfmt --to=iec $cache_size))${NC}"
                    total_freed=$((total_freed + cache_size))
                    files_removed=$((files_removed + cache_files))
                fi
            fi
        fi
        
        if [ "$clean_logs" = true ]; then
            local log_dir="${envdir}/var/log"
            if [ -d "$log_dir" ]; then
                local log_size=$(sudo du -sb "$log_dir" 2>/dev/null | awk '{print $1}' || echo "0")
                local log_files=$(sudo find "$log_dir" -type f -name "*.log*" 2>/dev/null | wc -l || echo "0")
                
                if [ "$dry_run" = true ]; then
                    echo -e "${YELLOW}${YELLOW}[DRY-RUN] System logs: ${NC} ${log_files} fichiers ($(numfmt --to=iec $log_size))${NC}"
                else
                    sudo find "$log_dir" -type f -name "*.log*" -delete 2>/dev/null
                    sudo find "$log_dir" -type f -name "*.old" -delete 2>/dev/null
                    echo -e "${GREEN}[✓] Logs cleaned: ${log_files} fichiers ($(numfmt --to=iec $log_size))${NC}"
                    total_freed=$((total_freed + log_size))
                    files_removed=$((files_removed + log_files))
                fi
            fi
        fi
        
        if [ "$clean_tmp" = true ]; then
            local tmp_dir="${envdir}/tmp"
            if [ -d "$tmp_dir" ]; then
                local tmp_size=$(sudo du -sb "$tmp_dir" 2>/dev/null | awk '{print $1}' || echo "0")
                local tmp_files=$(sudo find "$tmp_dir" -type f 2>/dev/null | wc -l || echo "0")
                
                if [ "$dry_run" = true ]; then
                    echo -e "${YELLOW}${YELLOW}[DRY-RUN] Temporary files: ${NC} ${tmp_files} fichiers ($(numfmt --to=iec $tmp_size))${NC}"
                else
                    sudo find "$tmp_dir" -type f -delete 2>/dev/null
                    echo -e "${GREEN}[✓] Temporary files cleaned: ${tmp_files} fichiers ($(numfmt --to=iec $tmp_size))${NC}"
                    total_freed=$((total_freed + tmp_size))
                    files_removed=$((files_removed + tmp_files))
                fi
            fi
        fi
        
        if [ "$dry_run" = false ] && [ $total_freed -gt 0 ]; then
            echo -e "${GREEN}[*] Environnement ${env} : ${files_removed} files removed, $(numfmt --to=iec $total_freed) freed${NC}"
            update_last_used "$env"
        fi
    }
    
    if [ "$all_envs" = true ]; then
        echo -e "${BLUE}[*] Cleaning all environments...${NC}"
        local env_count=0
        for env_path in "${ARCHSHELL_ENVS}"/*; do
            [ -d "$env_path" ] || continue
            local env_basename=$(basename "$env_path")
            [ "$env_basename" = "store" ] && continue
            [ -f "$env_path/.arch-shell-env" ] || continue
            
            clean_single_env "$env_basename"
            env_count=$((env_count + 1))
        done
        
        if [ $env_count -eq 0 ]; then
            echo -e "${YELLOW}[!] No environments found to clean${NC}"
        else
            echo -e "${GREEN}[*] $(echo "${GREEN}[*] Cleanup completed for") ${env_count} environment(s) ${env_count} environnement(s)${NC}"
        fi
    else
        if [ -z "$envname" ]; then
            echo -e "${RED}[!] Environment name required or use --all-envs${NC}"
            return 1
        fi
        clean_single_env "$envname"
    fi
}

run_command() {
    local envname="$1"
    local command=""
    local script_file=""
    local env_vars=""
    
    shift 1
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --script)
                script_file="$2"
                shift 2
                ;;
            --env)
                env_vars="$env_vars $2"
                shift 2
                ;;
            *)
                if [ -z "$command" ]; then
                    command="$1"
                else
                    command="$command $1"
                fi
                shift
                ;;
        esac
    done
    
    local envdir="${ARCHSHELL_ENVS}/${envname}"
    
    if [ ! -d "$envdir" ]; then
        echo -e "${RED}[!] Environment not found: ${envname}${NC}"
        return 1
    fi
    
    update_last_used "$envname"
    
    if [ -n "$script_file" ]; then
        if [ ! -f "$script_file" ]; then
            echo -e "${RED}[!] Script not found: ${script_file}${NC}"
            return 1
        fi
        
        echo -e "${BLUE}[*] Executing script ${script_file} in ${envname}...${NC}"
        
        local script_name=$(basename "$script_file")
        debug_run "sudo mkdir -p '${envdir}/root'"
        debug_run "sudo cp '$script_file' '${envdir}/root/${script_name}'"
        debug_run "sudo chmod +x '${envdir}/root/${script_name}'"
        
        debug_run "sudo arch-nspawn -c '$SHARED_CACHE/pkg' '$envdir' /bin/bash -c 'cd /root && ./${script_name}'"
        local exit_code=$?
        
        debug_run "sudo rm -f '${envdir}/root/${script_name}'"
        
        if [ $exit_code -eq 0 ]; then
            echo -e "${GREEN}[*] Script executed successfully${NC}"
        else
            echo -e "${RED}[!] Script terminated with error code ${exit_code}${NC}"
        fi
        
        return $exit_code
    else
        if [ -z "$command" ]; then
            echo -e "${RED}[!] No command specified${NC}"
            return 1
        fi
        
        echo -e "${BLUE}[*] Executing .${command}. in ${envname}...${NC}"
        
        if [ -n "$env_vars" ]; then
            debug_run "sudo arch-nspawn -c '$SHARED_CACHE/pkg' '$envdir' /bin/bash -c 'export $env_vars >/dev/null 2>&1; $command'"
        else
            debug_run "sudo arch-nspawn -c '$SHARED_CACHE/pkg' '$envdir' /bin/bash -c '$command'"
        fi
        
        local exit_code=$?
        
        if [ $exit_code -eq 0 ]; then
            echo -e "${GREEN}[*] Command executed successfully${NC}"
        else
            echo -e "${RED}[!] Command terminated with error code ${exit_code}${NC}"
        fi
        
        return $exit_code
    fi
}

SNAPSHOTS_DIR="${ARCHSHELL_DIR}/snapshots"

create_snapshot() {
    local envname="$1"
    local snapshot_name="$2"
    local envdir="${ARCHSHELL_ENVS}/${envname}"
    local env_snapshots_dir="${SNAPSHOTS_DIR}/${envname}"
    
    if [ ! -d "$envdir" ]; then
        echo -e "${RED}[!] Environment not found: ${envname}${NC}"
        exit 3
    fi
    
    mkdir -p "$env_snapshots_dir"
    
    if [ -z "$snapshot_name" ]; then
        snapshot_name="$(date +%Y-%m-%d_%H-%M-%S)"
    fi
    
    local snapshot_file="${env_snapshots_dir}/${snapshot_name}.tar.zst"
    
    if [ -f "$snapshot_file" ]; then
        echo -e "${RED}[!] The snapshot .${snapshot_name}. already exists${NC}"
        exit 4
    fi
    
    echo -e "${BLUE}[*] Creating snapshot .${snapshot_name}. for ${envname}...${NC}"
    
    (
        cd "${ARCHSHELL_ENVS}" && \
        debug_run "tar --zstd -cf '$snapshot_file' '${envname}'"
    ) &
    spinner $! "Creating snapshot"
    
    local metadata_file="${env_snapshots_dir}/snapshots.json"
    local snapshot_size=$(du -h "$snapshot_file" | cut -f1)
    local snapshot_date=$(date -Iseconds)
    
    if [ ! -f "$metadata_file" ]; then
        echo "[]" > "$metadata_file"
    fi
    
    if command -v jq >/dev/null 2>&1; then
        jq ". += [{\"name\": \"$snapshot_name\", \"date\": \"$snapshot_date\", \"size\": \"$snapshot_size\"}]" "$metadata_file" > "${metadata_file}.tmp" && mv "${metadata_file}.tmp" "$metadata_file"
    else
        echo "  {\"name\": \"$snapshot_name\", \"date\": \"$snapshot_date\", \"size\": \"$snapshot_size\"}" >> "$metadata_file.simple"
    fi
    
    echo -e "${GREEN}[*] Snapshot .${snapshot_name}. created (${snapshot_size})${NC}"
}

list_snapshots() {
    local envname="$1"
    local env_snapshots_dir="${SNAPSHOTS_DIR}/${envname}"
    
    if [ ! -d "${ARCHSHELL_ENVS}/${envname}" ]; then
        echo -e "${RED}[!] Environment not found: ${envname}${NC}"
        exit 3
    fi
    
    if [ ! -d "$env_snapshots_dir" ] || [ -z "$(ls -A "$env_snapshots_dir"/*.tar.{zst,xz} 2>/dev/null)" ]; then
        echo -e "${YELLOW}[*] No snapshots found for environment ${envname}${NC}"
        return
    fi
    
    echo -e "${BLUE}[*] Snapshots for environment '${envname}':${NC}"
    
    local i=1
    for snapshot_file in "$env_snapshots_dir"/*.tar.{zst,xz}; do
        if [ -f "$snapshot_file" ]; then
            local snapshot_name=$(basename "$snapshot_file")
            snapshot_name=${snapshot_name%.tar.*}
            local snapshot_size=$(du -h "$snapshot_file" | cut -f1)
            local snapshot_date=$(stat -c %y "$snapshot_file" | cut -d. -f1)
            local format=""
            if [[ "$snapshot_file" == *.tar.zst ]]; then
                format=" (zstd)"
            else
                format=" (legacy xz)"
            fi
            
            echo -e "  ${GREEN}${i}.${NC} ${snapshot_name} - ${snapshot_size} (${snapshot_date})${format}"
            ((i++))
        fi
    done
}

restore_snapshot() {
    local envname="$1"
    local snapshot_name="$2"
    local envdir="${ARCHSHELL_ENVS}/${envname}"
    local env_snapshots_dir="${SNAPSHOTS_DIR}/${envname}"
    
    if [ ! -d "$envdir" ]; then
        echo -e "${RED}[!] Environment not found: ${envname}${NC}"
        exit 3
    fi
    
    local snapshot_file
    if [[ "$snapshot_name" =~ ^[0-9]+$ ]]; then
        local i=1
        for file in "$env_snapshots_dir"/*.tar.{zst,xz}; do
            if [ -f "$file" ] && [ "$i" -eq "$snapshot_name" ]; then
                snapshot_file="$file"
                break
            fi
            ((i++))
        done
    else
        if [ -f "${env_snapshots_dir}/${snapshot_name}.tar.zst" ]; then
            snapshot_file="${env_snapshots_dir}/${snapshot_name}.tar.zst"
        elif [ -f "${env_snapshots_dir}/${snapshot_name}.tar.xz" ]; then
            snapshot_file="${env_snapshots_dir}/${snapshot_name}.tar.xz"
        else
            snapshot_file="${env_snapshots_dir}/${snapshot_name}.tar.zst"
        fi
    fi
    
    if [ ! -f "$snapshot_file" ]; then
        echo -e "${RED}[!] Snapshot .${snapshot_name}. not found${NC}"
        exit 5
    fi
    
    echo -e "${YELLOW}[!] WARNING: This operation will replace the current environment${NC}"
    if ! ask_confirmation "Continue? [o/N] "; then
        echo "Cancelled."
        exit 0
    fi
    
    echo -e "${BLUE}[*] Restoring snapshot for ${envname}...${NC}"
    
    local backup_name="backup-avant-restore-$(date +%Y%m%d%H%M%S)"
    mv "$envdir" "${envdir}.${backup_name}"
    
    (
        cd "${ARCHSHELL_ENVS}" && \
        if [[ "$snapshot_file" == *.tar.zst ]]; then
            debug_run "tar --zstd -xf '$snapshot_file'"
        else
            debug_run "tar -xJf '$snapshot_file'"
        fi
    ) &
    if [[ "$snapshot_file" == *.tar.zst ]]; then
        spinner $! "Snapshot restoration (zstd)"
    else
        spinner $! "Snapshot restoration (legacy xz)"
    fi
    
    if [ -d "$envdir" ]; then
        sudo rm -rf "${envdir}.${backup_name}"
        echo -e "${GREEN}[*] Snapshot restored successfully${NC}"
    else
        mv "${envdir}.${backup_name}" "$envdir"
        echo -e "${RED}[!] Restoration failed, environment restored${NC}"
        exit 6
    fi
}

delete_snapshot() {
    local envname="$1"
    local snapshot_name="$2"
    local env_snapshots_dir="${SNAPSHOTS_DIR}/${envname}"
    local snapshot_file="${env_snapshots_dir}/${snapshot_name}.tar.zst"
    
    if [ ! -d "${ARCHSHELL_ENVS}/${envname}" ]; then
        echo -e "${RED}[!] Environment not found: ${envname}${NC}"
        exit 3
    fi
    
    if [ ! -f "$snapshot_file" ]; then
        echo -e "${RED}[!] Snapshot .${snapshot_name}. not found${NC}"
        exit 5
    fi
    
    if ask_confirmation "Delete snapshot permanently '${snapshot_name}' ? [o/N] "; then
        rm -f "$snapshot_file"
        
        local metadata_file="${env_snapshots_dir}/snapshots.json"
        if [ -f "$metadata_file" ] && command -v jq >/dev/null 2>&1; then
            jq "map(select(.name != \"$snapshot_name\"))" "$metadata_file" > "${metadata_file}.tmp" && mv "${metadata_file}.tmp" "$metadata_file"
        fi
        
        echo -e "${GREEN}[*] Snapshot '${snapshot_name}' deleted${NC}"
    else
        echo "Cancelled."
    fi
}

copy_file() {
    local recursive=false
    local src=""
    local dest=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -r|--recursive)
                recursive=true
                shift
                ;;
            *)
                if [ -z "$src" ]; then
                    src="$1"
                elif [ -z "$dest" ]; then
                    dest="$1"
                else
                    echo -e "${RED}[!] Too many arguments${NC}"
                    usage_copy
                fi
                shift
                ;;
        esac
    done
    
    if [ -z "$src" ] || [ -z "$dest" ]; then
        echo -e "${RED}[!] Source and destination required${NC}"
        usage_copy
    fi
    
    local src_env=""
    local src_path=""
    local dest_env=""
    local dest_path=""
    
    if [[ "$src" =~ ^([^:]+):(.+)$ ]]; then
        src_env="${BASH_REMATCH[1]}"
        src_path="${BASH_REMATCH[2]}"
    else
        src_path="$src"
    fi
    
    if [[ "$dest" =~ ^([^:]+):(.+)$ ]]; then
        dest_env="${BASH_REMATCH[1]}"
        dest_path="${BASH_REMATCH[2]}"
    else
        dest_path="$dest"
    fi
    
    if [ -n "$src_env" ] && [ -n "$dest_env" ]; then
        echo -e "${RED}[!] Cannot copy directly between two environments${NC}"
        echo -e "${YELLOW}[?] Copy from env to local first, then from local to env${NC}"
        exit 1
    fi
    
    if [ -z "$src_env" ] && [ -z "$dest_env" ]; then
        echo -e "${RED}[!] At least one path must reference an environment (env:path)${NC}"
        usage_copy
    fi
    
    local envname=""
    local envdir=""
    
    if [ -n "$src_env" ]; then
        envname="$src_env"
        envdir="${ARCHSHELL_ENVS}/${envname}"
        
        if [ ! -d "$envdir" ]; then
            echo -e "${RED}[!] Environment not found: ${envname}${NC}"
            exit 3
        fi
        
        local full_src_path="${envdir}${src_path}"
        
        if [ ! -e "$full_src_path" ]; then
            echo -e "${RED}[!] Source file not found in environment: ${src_path}${NC}"
            exit 1
        fi
        
        if [ -d "$full_src_path" ] && [ "$recursive" = false ]; then
            echo -e "${RED}[!] Source is a directory. Use -r or --recursive${NC}"
            exit 1
        fi
        
        echo -e "${BLUE}[*] Copying from environment ${envname}:${src_path} to ${dest_path}...${NC}"
        
        if [ "$recursive" = true ]; then
            debug_run "sudo cp -r '$full_src_path' '$dest_path'"
        else
            debug_run "sudo cp '$full_src_path' '$dest_path'"
        fi
        
        if [ $? -eq 0 ]; then
            debug_run "sudo chown -R $USER: '$dest_path'"
            echo -e "${GREEN}[*] Copy completed successfully${NC}"
            update_last_used "$envname"
        else
            echo -e "${RED}[!] Copy failed${NC}"
            exit 1
        fi
        
    elif [ -n "$dest_env" ]; then
        envname="$dest_env"
        envdir="${ARCHSHELL_ENVS}/${envname}"
        
        if [ ! -d "$envdir" ]; then
            echo -e "${RED}[!] Environment not found: ${envname}${NC}"
            exit 3
        fi
        
        if [ ! -e "$src_path" ]; then
            echo -e "${RED}[!] Source file not found: ${src_path}${NC}"
            exit 1
        fi
        
        if [ -d "$src_path" ] && [ "$recursive" = false ]; then
            echo -e "${RED}[!] Source is a directory. Use -r or --recursive${NC}"
            exit 1
        fi
        
        local full_dest_path="${envdir}${dest_path}"
        local dest_parent_dir=$(dirname "$full_dest_path")
        
        echo -e "${BLUE}[*] Copying from ${src_path} to environment ${envname}:${dest_path}...${NC}"
        
        debug_run "sudo mkdir -p '$dest_parent_dir'"
        
        if [ "$recursive" = true ]; then
            debug_run "sudo cp -r '$src_path' '$full_dest_path'"
        else
            debug_run "sudo cp '$src_path' '$full_dest_path'"
        fi
        
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}[*] Copy completed successfully${NC}"
            update_last_used "$envname"
        else
            echo -e "${RED}[!] Copy failed${NC}"
            exit 1
        fi
    fi
}

while [ $# -gt 0 ]; do
    case "$1" in
        --debug)
            DEBUG=true
            shift
            debug_log "Debug mode enabled"
            ;;
        --no-color)
            NO_COLOR=true
            shift
            debug_log "No-color mode enabled"
            ;;
        --yes)
            YES=true
            shift
            debug_log "Automatic mode enabled"
            ;;
        --quiet)
            QUIET=true
            shift
            debug_log "Quiet mode enabled"
            ;;
        *)
            break
            ;;
    esac
done

init_colors

if [ $# -lt 1 ]; then
    usage
fi

case "$1" in
  init)
    mkdir -p "$ARCHSHELL_STORE"
    init_shared_cache
    if [ -d "$BASE_TEMPLATE" ]; then
      echo "Base template already exists. Use 'regen-base' to regenerate it."
    else
      echo -e "${BLUE}[*] Creating base template...${NC}"
      (
        debug_run "sudo mkarchroot '$BASE_TEMPLATE' base"
      ) &
      spinner $! "Creating base template"
      echo -e "${GREEN}[*] Base template created.${NC}"
    fi
    ;;
  regen-base)
    mkdir -p "$ARCHSHELL_STORE"
    init_shared_cache
    echo -e "${BLUE}[*] Regenerating base template...${NC}"
    if [ -d "$BASE_TEMPLATE" ]; then
      debug_run "sudo rm -rf '$BASE_TEMPLATE'"
    fi
    (
      debug_run "sudo mkarchroot '$BASE_TEMPLATE' base"
    ) &
    spinner $! "Regenerating base template"
    echo -e "${GREEN}[*] Base template regenerated.${NC}"
    ;;
  create)
    if [ $# -lt 2 ]; then
      echo "Usage: $0 create <env>"
      exit 1
    fi
    ENVNAME="$2"
    if [ ! -d "$BASE_TEMPLATE" ]; then
      echo "Base template not found. Run d'abord '$0 init'."
      exit 2
    fi
    if [ -d "${ARCHSHELL_ENVS}/${ENVNAME}" ]; then
      echo "The environment ${ENVNAME} already exists."; exit 5;
    fi
    echo -e "${BLUE}[*] Creating environment $ENVNAME from template...${NC}"
    mkdir -p "${ARCHSHELL_ENVS}/${ENVNAME}"
    total=$(sudo du -sb "$BASE_TEMPLATE" | awk '{print $1}')
    (
      debug_run "sudo rsync -a --info=progress2 '$BASE_TEMPLATE/' '${ARCHSHELL_ENVS}/${ENVNAME}/'"
    ) &
    spinner $! "Copying template"
    sudo chown -R $USER: "${ARCHSHELL_ENVS}/${ENVNAME}"
    update_env_info "$ENVNAME"
    echo -e "${GREEN}[*] Environment .*ENVNAME created.${NC}"
    ;;
  -S)
    if [ $# -lt 3 ]; then
      echo "Usage: $0 -S <env> <pkg...>"
      exit 1
    fi
    ENVNAME="$2"
    shift 2
    if [ ! -d "${ARCHSHELL_ENVS}/${ENVNAME}" ]; then
      echo "Environment not found: ${ENVNAME}"; exit 3;
    fi
    init_shared_cache
    cache_hits=0
    total_packages=$#
    for pkg in "$@"; do
        if track_cache_hit "$pkg"; then
            cache_hits=$((cache_hits + 1))
        fi
    done
    new_downloads=$((total_packages - cache_hits))
    
    echo -e "${BLUE}[*] Installing package(s) $* in $ENVNAME...${NC}"
    (
      debug_run "sudo arch-nspawn -c '$SHARED_CACHE/pkg' '${ARCHSHELL_ENVS}/${ENVNAME}' pacman -S --noconfirm $*"
    ) &
    install_pid=$!
    spinner $install_pid "Installing packages"
    wait $install_pid
    install_result=$?
    
    if [ $install_result -eq 0 ]; then
      echo -e "${GREEN}[*] Installation completed.${NC}"
      update_last_used "$ENVNAME"
      for pkg in "$@"; do
        add_package "$ENVNAME" "$pkg"
      done
      if [ $new_downloads -gt 0 ]; then
        track_download $new_downloads
      fi
      update_cache_stats
    else
      echo -e "${RED}[!] Installation failed (code: $install_result)${NC}"
      exit $install_result
    fi
    ;;
  -R)
    if [ $# -lt 3 ]; then
      echo "Usage: $0 -R <env> <pkg...>"
      exit 1
    fi
    ENVNAME="$2"
    shift 2
    if [ ! -d "${ARCHSHELL_ENVS}/${ENVNAME}" ]; then
      echo "Environment not found: ${ENVNAME}"; exit 3;
    fi
    init_shared_cache
    
    missing_packages=()
    for pkg in "$@"; do
      if ! check_package_in_env "$ENVNAME" "$pkg"; then
        missing_packages+=("$pkg")
      fi
    done
    
    if [ ${#missing_packages[@]} -gt 0 ]; then
      echo -e "${RED}[!] The following packages are not installed in environment ${ENVNAME} :${NC}"
      for pkg in "${missing_packages[@]}"; do
        echo "  - $pkg"
      done
      echo -e "${YELLOW}[!] Only packages present in .arch-shell-env can be removed.${NC}"
      exit 4
    fi
    
    echo -e "${BLUE}[*] Removing package(s) $* in $ENVNAME...${NC}"
    (
      debug_run "sudo arch-nspawn -c '$SHARED_CACHE/pkg' '${ARCHSHELL_ENVS}/${ENVNAME}' pacman -R --noconfirm $*"
    ) &
    remove_pid=$!
    spinner $remove_pid "Removing packages"
    wait $remove_pid
    remove_result=$?
    
    if [ $remove_result -eq 0 ]; then
      echo -e "${GREEN}[*] Removal completed.${NC}"
      update_last_used "$ENVNAME"
      for pkg in "$@"; do
        remove_package "$ENVNAME" "$pkg"
      done
    else
      echo -e "${RED}[!] Removal failed (code: $remove_result)${NC}"
      exit $remove_result
    fi
    ;;
  enter)
    if [ $# -lt 2 ]; then
      echo "Usage: $0 enter <env>"
      exit 1
    fi
    ENVNAME="$2"
    if [ ! -d "${ARCHSHELL_ENVS}/${ENVNAME}" ]; then
      echo "Environment not found: ${ENVNAME}"; exit 3;
    fi
    init_shared_cache
    echo "Entering environment $ENVNAME."
    update_last_used "$ENVNAME"
    sudo arch-nspawn -c "$SHARED_CACHE/pkg" "${ARCHSHELL_ENVS}/${ENVNAME}"
    ;;
  delete)
    if [ $# -lt 2 ]; then
      echo "Usage: $0 delete <env>"
      exit 1
    fi
    ENVNAME="$2"
    if [ ! -d "${ARCHSHELL_ENVS}/${ENVNAME}" ]; then
      echo "Environment not found: ${ENVNAME}"; exit 3;
    fi
    if ask_confirmation "Delete ${ENVNAME} permanently? [o/N] "; then
      sudo rm -rf "${ARCHSHELL_ENVS}/${ENVNAME}"
      LOCKFILE="${ARCHSHELL_ENVS}/${ENVNAME}.lock"
      if [ -f "$LOCKFILE" ]; then
        sudo rm -f "$LOCKFILE"
      fi
      echo "Environment deleted."
    else
      echo "Cancelled."
    fi
    ;;
  list)
    echo "Available environments:"
    for env in "$ARCHSHELL_ENVS"/*; do
      [ -d "$env" ] || continue
      [ "$(basename "$env")" = "store" ] && continue
      if [ -f "$env/.arch-shell-env" ]; then
        echo "- $(basename "$env")"
      fi
    done
    ;;
  info)
    if [ $# -lt 2 ]; then
      echo "Usage: $0 info <env>"
      exit 1
    fi
    ENVNAME="$2"
    INFOFILE="${ARCHSHELL_ENVS}/${ENVNAME}/.arch-shell-env"
    if [ ! -f "$INFOFILE" ]; then
      echo "Environment not found: ${ENVNAME}"; exit 3;
    fi
    echo "Information about environment ${ENVNAME}:"
    if command -v jq >/dev/null 2>&1; then
      jq '.' "$INFOFILE"
    else
      cat "$INFOFILE"
    fi
    ;;
  export)
    if [ $# -lt 3 ]; then
      echo "Usage: $0 export <env> <file>"
      exit 1
    fi
    ENVNAME="$2"
    EXPORT_FILE="$3"
    export_env "$ENVNAME" "$EXPORT_FILE"
    ;;
  import)
    if [ $# -lt 3 ]; then
      echo "Usage: $0 import <file> <env>"
      exit 1
    fi
    IMPORT_FILE="$2"
    ENVNAME="$3"
    import_env "$IMPORT_FILE" "$ENVNAME"
    ;;
  run)
    if [ $# -lt 2 ]; then
      usage_run
    fi
    ENVNAME="$2"
    shift 2
    run_command "$ENVNAME" "$@"
    ;;
  clean)
    if [ $# -lt 1 ]; then
      usage_clean
    fi
    if [ $# -ge 2 ] && [ "$2" = "--all-envs" ]; then
      shift 1
      clean_env "" "$@"
    else
      if [ $# -lt 2 ]; then
        usage_clean
      fi
      ENVNAME="$2"
      shift 2
      clean_env "$ENVNAME" "$@"
    fi
    ;;
  snapshot)
    if [ $# -lt 2 ]; then
      usage_snapshot
    fi
    
    if [ $# -ge 3 ] && [ "$3" = "--list" ]; then
      list_snapshots "$2"
    elif [ $# -ge 3 ] && [ "$3" = "--restore" ]; then
      if [ $# -lt 4 ]; then
        echo "Usage: $0 snapshot <env> --restore <snapshot>"
        exit 1
      fi
      restore_snapshot "$2" "$4"
    elif [ $# -ge 3 ] && [ "$3" = "--delete" ]; then
      if [ $# -lt 4 ]; then
        echo "Usage: $0 snapshot <env> --delete <snapshot>"
        exit 1
      fi
      delete_snapshot "$2" "$4"
    else
      create_snapshot "$2" "${3:-}"
    fi
    ;;
  cache)
    if [ $# -lt 2 ]; then
      usage_cache
    fi
    case "${2:-}" in
      --stats)
        init_shared_cache
        show_cache_stats
        ;;
      --list)
        init_shared_cache
        echo -e "${BLUE}[*] Packages in shared cache:${NC}"
        if [ ! -d "$SHARED_CACHE/pkg" ] || [ -z "$(ls -A "$SHARED_CACHE/pkg" 2>/dev/null)" ]; then
          echo -e "${YELLOW}[*] Aucun paquet dans le cache${NC}"
        else
          total_count=0
          total_size=0
          declare -A seen_packages
          
          for pkg in "$SHARED_CACHE/pkg"/*.pkg.tar.*; do
            [ -f "$pkg" ] || continue
            pkg_name=$(basename "$pkg")
            
            [[ "$pkg_name" == *.sig ]] && continue
            
            pkg_clean=$(echo "$pkg_name" | sed 's/\.pkg\.tar\..*//')
            
            [ "${seen_packages[$pkg_clean]:-}" ] && continue
            seen_packages[$pkg_clean]=1
            
            pkg_size=$(stat -c%s "$pkg" 2>/dev/null || echo "0")
            
            echo -e "  ${GREEN}•${NC} $pkg_clean ($(numfmt --to=iec $pkg_size))"
            total_count=$((total_count + 1))
            total_size=$((total_size + pkg_size))
          done
          
          echo ""
          echo -e "${BLUE}[*] Total: .* packages ($(numfmt --to=iec $total_size))${NC}"
        fi
        ;;
      --clean)
        init_shared_cache
        days_old="${3:-30}"
        echo -e "${BLUE}[*] Cleaning shared cache (packages > ${days_old} days)...${NC}"
        before_count=$(find "$SHARED_CACHE/pkg" -name "*.pkg.tar.*" 2>/dev/null | wc -l || echo "0")
        before_size=$(du -sb "$SHARED_CACHE/pkg" 2>/dev/null | awk '{print $1}' || echo "0")
        
        find "$SHARED_CACHE/pkg" -name "*.pkg.tar.*" -mtime +$days_old -delete 2>/dev/null
        
        after_count=$(find "$SHARED_CACHE/pkg" -name "*.pkg.tar.*" 2>/dev/null | wc -l || echo "0")
        after_size=$(du -sb "$SHARED_CACHE/pkg" 2>/dev/null | awk '{print $1}' || echo "0")
        freed=$((before_size - after_size))
        removed=$((before_count - after_count))
        
        echo -e "${GREEN}[*] Cache cleaned: .* packages removed ($(numfmt --to=iec $freed) freed)${NC}"
        update_cache_stats
        ;;
      *)
        exit 1
        ;;
    esac
    ;;
  copy)
    if [ $# -lt 3 ]; then
      usage_copy
    fi
    shift 1
    copy_file "$@"
    ;;
  *)
    usage
    ;;
esac