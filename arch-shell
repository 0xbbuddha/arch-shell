#!/bin/bash

# =============================================
# Script : arch-shell
# Description : Gestion des environnements Arch Linux
# Auteur : Killian Prin-abeil <killian@archimedeos.org>
# Date : $(date +%Y-%m-%d)
# =============================================

set -euo pipefail

DEBUG=false
NO_COLOR=false
YES=false
QUIET=false
ARCHSHELL_DIR="${HOME}/.arch-shell"
ARCHSHELL_ENVS="${ARCHSHELL_DIR}/envs"
ARCHSHELL_STORE="${ARCHSHELL_DIR}/store"
BASE_TEMPLATE="${ARCHSHELL_STORE}/base-template"
SHARED_CACHE="${ARCHSHELL_DIR}/cache"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

init_colors() {
    if [ "$NO_COLOR" = true ]; then
        RED=''
        GREEN=''
        YELLOW=''
        BLUE=''
        NC=''
    fi
}

ask_confirmation() {
    local prompt="$1"
    local default="${2:-N}"
    
    if [ "$YES" = true ]; then
        echo -e "${GREEN}[*] ${prompt} [AUTO-YES]${NC}"
        return 0
    fi
    
    read -p "$prompt" -r
    if [[ $REPLY =~ ^[oOyY]$ ]]; then
        return 0
    else
        return 1
    fi
}

quiet_log() {
    if [ "$QUIET" != true ]; then
        echo -e "$@"
    fi
}

error_log() {
    echo -e "$@" >&2
}

spinner() {
  local pid=$1
  local msg="$2"
  local spinstr='|/-\\'
  local i=0
  
  if [ "$QUIET" = true ]; then
    wait $pid
    return
  fi
  
  tput civis
  while kill -0 $pid 2>/dev/null; do
    i=$(( (i+1) %4 ))
    printf "\r${YELLOW}[*] %s %s${NC}" "${spinstr:$i:1}" "$msg"
    sleep 0.1
  done
  printf "\r${GREEN}[*] %s terminé !${NC}\n" "$msg"
  tput cnorm
}

debug_log() {
    if [ "$DEBUG" = true ]; then
        echo -e "${BLUE}[DEBUG]${NC} $*" >&2
    fi
}

debug_run() {
    local cmd="$*"
    debug_log "Exécution: $cmd"
    
    if [ "$DEBUG" = true ]; then
        eval "$cmd"
        return $?
    else
        eval "$cmd" > /dev/null 2>&1
        return $?
    fi
}

usage() {
    echo "Usage: $0 [--debug] [--no-color] [--yes] [--quiet] <command> [options]"
    echo ""
    echo "Options globales:"
    echo "  --debug             Afficher les commandes et sorties en temps réel"
    echo "  --no-color          Désactiver les couleurs dans la sortie"
    echo "  --yes               Répondre automatiquement 'oui' aux confirmations"
    echo "  --quiet             Afficher seulement les erreurs"
    echo ""
    echo "Commandes:"
    echo "  init                Initialiser arch-shell"
    echo "  regen-base          Régénérer le template de base"
    echo "  create <env>        Créer un nouvel environnement"
    echo "  -S <env> <pkg...>   Installer des paquets dans un environnement"
    echo "  -R <env> <pkg...>   Supprimer des paquets d'un environnement"
    echo "  enter <env>         Entrer dans un environnement"
    echo "  delete <env>        Supprimer un environnement"
    echo "  list                Lister tous les environnements"
    echo "  info <env>          Afficher les informations d'un environnement"
    echo "  export <env> <file> Exporter un environnement"
    echo "  import <file> <env> Importer un environnement"
    echo "  run <env> <command> Exécuter une commande dans un environnement"
    echo "  clean <env>         Nettoyer un environnement"
    echo "  snapshot <env>      Gérer les snapshots d'un environnement"
    echo "  cache <options>     Interagir avec le cache partagé"
    exit 1
}

usage_run() {
    echo "Usage: $0 run <env> <command> [options]"
    echo ""
    echo "Exécute une commande ou un script dans un environnement."
    echo ""
    echo "Options:"
    echo "  --script <file>     Exécuter un script dans l'environnement"
    echo "  --env <VAR=value>   Définir une variable d'environnement"
    echo ""
    echo "Exemples:"
    echo "  $0 run mon-env \"ls -la\""
    echo "  $0 run mon-env \"make clean && make\""
    echo "  $0 run mon-env --script build.sh"
    echo "  $0 run mon-env --env DEBUG=1 \"./mon-programme\""
    echo "  $0 run mon-env --env BUILD_TYPE=release --script deploy.sh"
    exit 1
}

usage_snapshot() {
    echo "Usage: $0 snapshot <env> [nom] | $0 snapshot <env> <option>"
    echo ""
    echo "Gère les snapshots (sauvegardes) d'un environnement."
    echo ""
    echo "Options:"
    echo "  --list              Lister tous les snapshots de l'environnement"
    echo "  --restore <snap>    Restaurer un snapshot (par nom ou numéro)"
    echo "  --delete <snap>     Supprimer un snapshot (par nom)"
    echo ""
    echo "Exemples:"
    echo "  $0 snapshot mon-env                        Créer un snapshot avec nom automatique"
    echo "  $0 snapshot mon-env \"avant-test\"           Créer un snapshot nommé"
    echo "  $0 snapshot mon-env --list                 Lister les snapshots"
    echo "  $0 snapshot mon-env --restore \"avant-test\" Restaurer par nom"
    echo "  $0 snapshot mon-env --restore 1            Restaurer par numéro"
    echo "  $0 snapshot mon-env --delete \"avant-test\"  Supprimer un snapshot"
    exit 1
}

usage_clean() {
    echo "Usage: $0 clean <env> [options]"
    echo ""
    echo "Nettoie les fichiers temporaires et caches d'un environnement."
    echo ""
    echo "Options:"
    echo "  --cache             Nettoyer seulement les caches pacman"
    echo "  --logs              Nettoyer seulement les logs système"
    echo "  --tmp               Nettoyer seulement les fichiers temporaires"
    echo "  --all               Nettoyer tout (cache + logs + tmp)"
    echo "  --dry-run           Afficher ce qui serait nettoyé sans le faire"
    echo "  --all-envs          Nettoyer tous les environnements"
    echo ""
    echo "Exemples:"
    echo "  $0 clean mon-env                Nettoyage standard (cache + tmp)"
    echo "  $0 clean mon-env --all          Nettoyage complet"
    echo "  $0 clean mon-env --dry-run      Aperçu du nettoyage"
    echo "  $0 clean mon-env --cache        Seulement les caches"
    echo "  $0 clean --all-envs             Nettoyer tous les environnements"
    echo "  $0 clean --all-envs --dry-run   Aperçu pour tous les environnements"
    exit 1
}

init_shared_cache() {
    debug_log "Initialisation du cache partagé dans $SHARED_CACHE"
    mkdir -p "$SHARED_CACHE/pkg"
    mkdir -p "$SHARED_CACHE/db"
    
    local stats_file="$SHARED_CACHE/cache-stats.json"
    if [ ! -f "$stats_file" ]; then
        cat > "$stats_file" << EOF
{
  "created": "$(date -Iseconds)",
  "total_downloads": 0,
  "cache_hits": 0,
  "total_size": 0,
  "packages_count": 0,
  "last_updated": "$(date -Iseconds)"
}
EOF
        debug_log "Fichier de statistiques du cache créé"
    fi
}

update_cache_stats() {
    local stats_file="$SHARED_CACHE/cache-stats.json"
    local pkg_count=$(find "$SHARED_CACHE/pkg" -name "*.pkg.tar.*" 2>/dev/null | wc -l || echo "0")
    local total_size=$(du -sb "$SHARED_CACHE/pkg" 2>/dev/null | awk '{print $1}' || echo "0")
    
    if [ -f "$stats_file" ] && command -v jq >/dev/null 2>&1; then
        jq ".packages_count = $pkg_count | .total_size = $total_size | .last_updated = \"$(date -Iseconds)\"" "$stats_file" > "${stats_file}.tmp" && mv "${stats_file}.tmp" "$stats_file"
    fi
}

track_cache_hit() {
    local pkg="$1"
    local stats_file="$SHARED_CACHE/cache-stats.json"
    
    if find "$SHARED_CACHE/pkg" -name "${pkg}-*.pkg.tar.*" -type f 2>/dev/null | head -1 | grep -q .; then
        echo -e "${GREEN}[*] Cache hit pour ${pkg}${NC}"
        
        if [ -f "$stats_file" ] && command -v jq >/dev/null 2>&1; then
            local hits=$(jq -r '.cache_hits // 0' "$stats_file" 2>/dev/null || echo "0")
            if [ "$hits" != "null" ] && [ -n "$hits" ]; then
                jq ".cache_hits = $((hits + 1))" "$stats_file" > "${stats_file}.tmp" && mv "${stats_file}.tmp" "$stats_file" 2>/dev/null || true
            fi
        fi
        return 0
    fi
    return 1
}

track_download() {
    local stats_file="$SHARED_CACHE/cache-stats.json"
    local packages_count="$1"
    
    if [ -f "$stats_file" ] && command -v jq >/dev/null 2>&1; then
        local downloads=$(jq -r '.total_downloads // 0' "$stats_file" 2>/dev/null || echo "0")
        if [ "$downloads" != "null" ] && [ -n "$downloads" ]; then
            jq ".total_downloads = $((downloads + packages_count))" "$stats_file" > "${stats_file}.tmp" && mv "${stats_file}.tmp" "$stats_file" 2>/dev/null || true
        fi
    fi
}

show_cache_stats() {
    local stats_file="$SHARED_CACHE/cache-stats.json"
    local cache_size=$(du -sh "$SHARED_CACHE/pkg" 2>/dev/null | awk '{print $1}' || echo "0")
    local pkg_count=$(find "$SHARED_CACHE/pkg" -name "*.pkg.tar.*" 2>/dev/null | wc -l || echo "0")
    
    echo -e "${BLUE}[*] Statistiques du cache partagé arch-shell :${NC}"
    echo -e "${GREEN}  Paquets en cache : ${pkg_count}${NC}"
    echo -e "${GREEN}  Taille du cache : ${cache_size}${NC}"
    
    if [ -f "$stats_file" ] && command -v jq >/dev/null 2>&1; then
        local hits=$(jq -r '.cache_hits // 0' "$stats_file" 2>/dev/null || echo "0")
        local downloads=$(jq -r '.total_downloads // 0' "$stats_file" 2>/dev/null || echo "0")
        local created=$(jq -r '.created // "N/A"' "$stats_file" 2>/dev/null || echo "N/A")
        
        echo -e "${GREEN}  Cache hits : ${hits}${NC}"
        echo -e "${GREEN}  Téléchargements : ${downloads}${NC}"
        echo -e "${GREEN}  Créé le : ${created}${NC}"
        
        if [ "$downloads" -gt 0 ]; then
            local hit_rate=$((hits * 100 / (hits + downloads)))
            echo -e "${GREEN}  Taux de cache hits : ${hit_rate}%${NC}"
        fi
    fi
}

update_env_info() {
    local envname="$1"
    local envdir="${ARCHSHELL_ENVS}/${envname}"
    local infofile="${envdir}/.arch-shell-env"
    
    cat > "$infofile" << EOF
{
  "name": "$envname",
  "created": "$(date -Iseconds)",
  "last_used": "$(date -Iseconds)",
  "packages": [],
  "arch": "$(uname -m)"
}
EOF
}

update_last_used() {
    local envname="$1"
    local infofile="${ARCHSHELL_ENVS}/${envname}/.arch-shell-env"
    if [ -f "$infofile" ]; then
        if command -v jq >/dev/null 2>&1; then
            jq ".last_used = \"$(date -Iseconds)\"" "$infofile" > "${infofile}.tmp" && mv "${infofile}.tmp" "$infofile"
        else
            sed -i "s/\"last_used\": \"[^\"]*\"/\"last_used\": \"$(date -Iseconds)\"/" "$infofile"
        fi
    fi
}

add_package() {
    local envname="$1"
    local package="$2"
    local infofile="${ARCHSHELL_ENVS}/${envname}/.arch-shell-env"
    
    if [ -f "$infofile" ]; then
        if command -v jq >/dev/null 2>&1; then
            jq ".packages += [\"$package\"]" "$infofile" > "${infofile}.tmp" && mv "${infofile}.tmp" "$infofile"
        else
            sed -i "s/\"packages\": \[\([^]]*\)\]/\"packages\": [\1, \"$package\"]/" "$infofile"
        fi
    fi
}

remove_package() {
    local envname="$1"
    local package="$2"
    local infofile="${ARCHSHELL_ENVS}/${envname}/.arch-shell-env"
    
    if [ -f "$infofile" ]; then
        if command -v jq >/dev/null 2>&1; then
            jq ".packages -= [\"$package\"]" "$infofile" > "${infofile}.tmp" && mv "${infofile}.tmp" "$infofile"
        else
            sed -i "s/\"$package\",\?//g; s/,\s*]/]/g; s/\[,/[/g" "$infofile"
        fi
    fi
}

check_package_in_env() {
    local envname="$1"
    local package="$2"
    local infofile="${ARCHSHELL_ENVS}/${envname}/.arch-shell-env"
    
    if [ -f "$infofile" ]; then
        if command -v jq >/dev/null 2>&1; then
            jq -e ".packages | index(\"$package\")" "$infofile" >/dev/null 2>&1
        else
            grep -q "\"$package\"" "$infofile"
        fi
    else
        return 1
    fi
}

export_env() {
    local envname="$1"
    local export_file="$2"
    local envdir="${ARCHSHELL_ENVS}/${envname}"
    local infofile="${envdir}/.arch-shell-env"
    
    if [ ! -d "$envdir" ]; then
        echo -e "${RED}[!] Environnement inexistant : ${envname}${NC}"
        return 1
    fi
    
    if [ ! -f "$infofile" ]; then
        echo -e "${RED}[!] Fichier de métadonnées manquant : ${infofile}${NC}"
        return 1
    fi
    
    if [ -d "$export_file" ]; then
        echo -e "${RED}[!] Le fichier d'export ne peut pas être un répertoire : ${export_file}${NC}"
        echo -e "${YELLOW}[?] Utilisez un nom de fichier comme : ${envname}-backup.tar.gz${NC}"
        return 1
    fi
    
    if [ -f "$export_file" ]; then
        echo -e "${YELLOW}[?] Le fichier ${export_file} existe déjà${NC}"
        if ! ask_confirmation "Écraser le fichier existant ? [o/N] "; then
            echo -e "${YELLOW}[!] Export annulé${NC}"
            return 1
        fi
    fi
    
    export_file=$(realpath "$export_file" 2>/dev/null || echo "$export_file")
    
    local temp_dir
    temp_dir=$(mktemp -d)
    local export_dir="${temp_dir}/export"
    mkdir -p "$export_dir"
    
    echo -e "${BLUE}[*] Préparation de l'export de ${envname}...${NC}"
    
    cat > "${envdir}/.arch-shell-export-metadata.json" << EOF
{
  "arch_shell_version": "$(grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+' "$0" 2>/dev/null || echo 'unknown')",
  "export_date": "$(date -Iseconds)",
  "environment_name": "$envname",
  "exported_by": "$(whoami)",
  "hostname": "$(hostname)",
  "arch": "$(uname -m)"
}
EOF
    
    local total_size
    total_size=$(sudo du -sb "$envdir" | awk '{print $1}')
    echo -e "${BLUE}[*] Création de l'archive optimisée ($(numfmt --to=iec $total_size))...${NC}"
    
    (
        cd "$envdir"
        debug_run "sudo tar --zstd -cf '$export_file' ."
    ) &
    spinner $! "Compression directe avec zstd"
    
    rm -f "${envdir}/.arch-shell-export-metadata.json"
    
    local checksum
    checksum=$(sha256sum "$export_file" | awk '{print $1}')
    
    rm -rf "$temp_dir"
    
    quiet_log "${GREEN}[*] Export terminé : ${export_file}${NC}"
    quiet_log "${GREEN}[*] Checksum SHA256 : ${checksum}${NC}"
    
    local archive_size
    archive_size=$(du -h "$export_file" | awk '{print $1}')
    quiet_log "${GREEN}[*] Taille de l'archive : ${archive_size}${NC}"
}

import_env() {
    local import_file="$1"
    local envname="$2"
    local envdir="${ARCHSHELL_ENVS}/${envname}"
    
    if [ ! -f "$import_file" ]; then
        echo -e "${RED}[!] Fichier d'import inexistant : ${import_file}${NC}"
        return 1
    fi
    
    if [ -d "$envdir" ]; then
        echo -e "${RED}[!] L'environnement ${envname} existe déjà${NC}"
        echo -e "${YELLOW}[?] Utilisez 'arch-shell delete ${envname}' pour le supprimer d'abord${NC}"
        return 1
    fi
    
    local temp_dir
    temp_dir=$(mktemp -d)
    
    echo -e "${BLUE}[*] Vérification et extraction de l'archive optimisée...${NC}"
    
    if tar --zstd -tf "$import_file" >/dev/null 2>&1; then
        echo -e "${BLUE}[*] Archive zstd détectée (format optimisé)${NC}"
        
        mkdir -p "$envdir"
        (
            cd "$envdir"
            debug_run "sudo tar --zstd -xf '$import_file'"
        ) &
        spinner $! "Extraction directe avec zstd"
        
        if [ -f "${envdir}/.arch-shell-export-metadata.json" ] && command -v jq >/dev/null 2>&1; then
            echo -e "${BLUE}[*] Informations de l'archive :${NC}"
            echo -e "${BLUE}    Archive :${NC} $(jq -r '.export_date' "${envdir}/.arch-shell-export-metadata.json" 2>/dev/null || echo 'unknown')"
            echo -e "${BLUE}    Environnement :${NC} $(jq -r '.environment_name' "${envdir}/.arch-shell-export-metadata.json" 2>/dev/null || echo 'unknown')"
            echo -e "${BLUE}    Exporté par :${NC} $(jq -r '.exported_by' "${envdir}/.arch-shell-export-metadata.json" 2>/dev/null || echo 'unknown')"
            rm -f "${envdir}/.arch-shell-export-metadata.json"
        fi
        
    else
        echo -e "${BLUE}[*] Archive gzip détectée (ancien format)${NC}"
        
        if ! tar xzf "$import_file" -C "$temp_dir" 2>/dev/null; then
            echo -e "${RED}[!] Erreur lors de l'extraction de l'archive${NC}"
            rm -rf "$temp_dir"
            return 1
        fi
        
        local export_dir="${temp_dir}/export"
        if [ ! -d "$export_dir" ] || [ ! -f "${export_dir}/environment.tar.gz" ]; then
            echo -e "${RED}[!] Archive incomplète ou corrompue${NC}"
            rm -rf "$temp_dir"
            return 1
        fi
        
        mkdir -p "$envdir"
        (
            cd "$envdir"
            gzip -dc "${export_dir}/environment.tar.gz" | sudo tar xf -
        ) &
        spinner $! "Extraction de l'environnement (ancien format)"
        
        if [ -f "${export_dir}/arch-shell-env.json" ]; then
            cp "${export_dir}/arch-shell-env.json" "${envdir}/.arch-shell-env"
        fi
    fi
    
    sudo chown -R $USER: "$envdir"
    update_last_used "$envname"
    rm -rf "$temp_dir"
    
    echo -e "${GREEN}[*] Import terminé : environnement ${envname} créé${NC}"
}

clean_env() {
    local envname="$1"
    local clean_cache=false
    local clean_logs=false
    local clean_tmp=false
    local clean_all=false
    local dry_run=false
    local all_envs=false
    
    shift 1
    while [[ $# -gt 0 ]]; do
        case $1 in
            --cache)
                clean_cache=true
                shift
                ;;
            --logs)
                clean_logs=true
                shift
                ;;
            --tmp)
                clean_tmp=true
                shift
                ;;
            --all)
                clean_all=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --all-envs)
                all_envs=true
                shift
                ;;
            *)
                echo -e "${RED}[!] Option inconnue : $1${NC}"
                return 1
                ;;
        esac
    done
    
    if [ "$clean_cache" = false ] && [ "$clean_logs" = false ] && [ "$clean_tmp" = false ] && [ "$clean_all" = false ]; then
        clean_cache=true
        clean_tmp=true
    fi
    
    if [ "$clean_all" = true ]; then
        clean_cache=true
        clean_logs=true
        clean_tmp=true
    fi
    
    clean_single_env() {
        local env="$1"
        local envdir="${ARCHSHELL_ENVS}/${env}"
        
        if [ ! -d "$envdir" ]; then
            echo -e "${RED}[!] Environnement inexistant : ${env}${NC}"
            return 1
        fi
        
        echo -e "${BLUE}[*] Nettoyage de l'environnement ${env}...${NC}"
        
        local total_freed=0
        local files_removed=0
        
        if [ "$clean_cache" = true ]; then
            local cache_dir="${envdir}/var/cache/pacman/pkg"
            if [ -d "$cache_dir" ]; then
                local cache_size=$(sudo du -sb "$cache_dir" 2>/dev/null | awk '{print $1}' || echo "0")
                local cache_files=$(sudo find "$cache_dir" -name "*.pkg.tar.*" 2>/dev/null | wc -l || echo "0")
                
                if [ "$dry_run" = true ]; then
                    echo -e "${YELLOW}[DRY-RUN] Cache pacman : ${cache_files} fichiers ($(numfmt --to=iec $cache_size))${NC}"
                else
                    sudo find "$cache_dir" -name "*.pkg.tar.*" -delete 2>/dev/null
                    echo -e "${GREEN}[✓] Cache pacman nettoyé : ${cache_files} fichiers ($(numfmt --to=iec $cache_size))${NC}"
                    total_freed=$((total_freed + cache_size))
                    files_removed=$((files_removed + cache_files))
                fi
            fi
        fi
        
        if [ "$clean_logs" = true ]; then
            local log_dir="${envdir}/var/log"
            if [ -d "$log_dir" ]; then
                local log_size=$(sudo du -sb "$log_dir" 2>/dev/null | awk '{print $1}' || echo "0")
                local log_files=$(sudo find "$log_dir" -type f -name "*.log*" 2>/dev/null | wc -l || echo "0")
                
                if [ "$dry_run" = true ]; then
                    echo -e "${YELLOW}[DRY-RUN] Logs système : ${log_files} fichiers ($(numfmt --to=iec $log_size))${NC}"
                else
                    sudo find "$log_dir" -type f -name "*.log*" -delete 2>/dev/null
                    sudo find "$log_dir" -type f -name "*.old" -delete 2>/dev/null
                    echo -e "${GREEN}[✓] Logs nettoyés : ${log_files} fichiers ($(numfmt --to=iec $log_size))${NC}"
                    total_freed=$((total_freed + log_size))
                    files_removed=$((files_removed + log_files))
                fi
            fi
        fi
        
        if [ "$clean_tmp" = true ]; then
            local tmp_dir="${envdir}/tmp"
            if [ -d "$tmp_dir" ]; then
                local tmp_size=$(sudo du -sb "$tmp_dir" 2>/dev/null | awk '{print $1}' || echo "0")
                local tmp_files=$(sudo find "$tmp_dir" -type f 2>/dev/null | wc -l || echo "0")
                
                if [ "$dry_run" = true ]; then
                    echo -e "${YELLOW}[DRY-RUN] Fichiers temporaires : ${tmp_files} fichiers ($(numfmt --to=iec $tmp_size))${NC}"
                else
                    sudo find "$tmp_dir" -type f -delete 2>/dev/null
                    echo -e "${GREEN}[✓] Temporaires nettoyés : ${tmp_files} fichiers ($(numfmt --to=iec $tmp_size))${NC}"
                    total_freed=$((total_freed + tmp_size))
                    files_removed=$((files_removed + tmp_files))
                fi
            fi
        fi
        
        if [ "$dry_run" = false ] && [ $total_freed -gt 0 ]; then
            echo -e "${GREEN}[*] Environnement ${env} : ${files_removed} fichiers supprimés, $(numfmt --to=iec $total_freed) libérés${NC}"
            update_last_used "$env"
        fi
    }
    
    if [ "$all_envs" = true ]; then
        echo -e "${BLUE}[*] Nettoyage de tous les environnements...${NC}"
        local env_count=0
        for env_path in "${ARCHSHELL_ENVS}"/*; do
            [ -d "$env_path" ] || continue
            local env_basename=$(basename "$env_path")
            [ "$env_basename" = "store" ] && continue
            [ -f "$env_path/.arch-shell-env" ] || continue
            
            clean_single_env "$env_basename"
            env_count=$((env_count + 1))
        done
        
        if [ $env_count -eq 0 ]; then
            echo -e "${YELLOW}[!] Aucun environnement trouvé à nettoyer${NC}"
        else
            echo -e "${GREEN}[*] Nettoyage terminé pour ${env_count} environnement(s)${NC}"
        fi
    else
        if [ -z "$envname" ]; then
            echo -e "${RED}[!] Nom d'environnement requis ou utilisez --all-envs${NC}"
            return 1
        fi
        clean_single_env "$envname"
    fi
}

run_command() {
    local envname="$1"
    local command=""
    local script_file=""
    local env_vars=""
    
    shift 1
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --script)
                script_file="$2"
                shift 2
                ;;
            --env)
                env_vars="$env_vars $2"
                shift 2
                ;;
            *)
                if [ -z "$command" ]; then
                    command="$1"
                else
                    command="$command $1"
                fi
                shift
                ;;
        esac
    done
    
    local envdir="${ARCHSHELL_ENVS}/${envname}"
    
    if [ ! -d "$envdir" ]; then
        echo -e "${RED}[!] Environnement inexistant : ${envname}${NC}"
        return 1
    fi
    
    update_last_used "$envname"
    
    if [ -n "$script_file" ]; then
        if [ ! -f "$script_file" ]; then
            echo -e "${RED}[!] Script inexistant : ${script_file}${NC}"
            return 1
        fi
        
        echo -e "${BLUE}[*] Exécution du script ${script_file} dans ${envname}...${NC}"
        
        local script_name=$(basename "$script_file")
        debug_run "sudo mkdir -p '${envdir}/root'"
        debug_run "sudo cp '$script_file' '${envdir}/root/${script_name}'"
        debug_run "sudo chmod +x '${envdir}/root/${script_name}'"
        
        debug_run "sudo arch-nspawn -c '$SHARED_CACHE/pkg' '$envdir' /bin/bash -c 'cd /root && ./${script_name}'"
        local exit_code=$?
        
        debug_run "sudo rm -f '${envdir}/root/${script_name}'"
        
        if [ $exit_code -eq 0 ]; then
            echo -e "${GREEN}[*] Script exécuté avec succès${NC}"
        else
            echo -e "${RED}[!] Script terminé avec le code d'erreur ${exit_code}${NC}"
        fi
        
        return $exit_code
    else
        if [ -z "$command" ]; then
            echo -e "${RED}[!] Aucune commande spécifiée${NC}"
            return 1
        fi
        
        echo -e "${BLUE}[*] Exécution de '${command}' dans ${envname}...${NC}"
        
        if [ -n "$env_vars" ]; then
            debug_run "sudo arch-nspawn -c '$SHARED_CACHE/pkg' '$envdir' /bin/bash -c 'export $env_vars >/dev/null 2>&1; $command'"
        else
            debug_run "sudo arch-nspawn -c '$SHARED_CACHE/pkg' '$envdir' /bin/bash -c '$command'"
        fi
        
        local exit_code=$?
        
        if [ $exit_code -eq 0 ]; then
            echo -e "${GREEN}[*] Commande exécutée avec succès${NC}"
        else
            echo -e "${RED}[!] Commande terminée avec le code d'erreur ${exit_code}${NC}"
        fi
        
        return $exit_code
    fi
}

SNAPSHOTS_DIR="${ARCHSHELL_DIR}/snapshots"

create_snapshot() {
    local envname="$1"
    local snapshot_name="$2"
    local envdir="${ARCHSHELL_ENVS}/${envname}"
    local env_snapshots_dir="${SNAPSHOTS_DIR}/${envname}"
    
    if [ ! -d "$envdir" ]; then
        echo -e "${RED}[!] Environnement inexistant : ${envname}${NC}"
        exit 3
    fi
    
    mkdir -p "$env_snapshots_dir"
    
    if [ -z "$snapshot_name" ]; then
        snapshot_name="$(date +%Y-%m-%d_%H-%M-%S)"
    fi
    
    local snapshot_file="${env_snapshots_dir}/${snapshot_name}.tar.zst"
    
    if [ -f "$snapshot_file" ]; then
        echo -e "${RED}[!] Le snapshot '${snapshot_name}' existe déjà${NC}"
        exit 4
    fi
    
    echo -e "${BLUE}[*] Création du snapshot '${snapshot_name}' pour ${envname}...${NC}"
    
    (
        cd "${ARCHSHELL_ENVS}" && \
        debug_run "tar --zstd -cf '$snapshot_file' '${envname}'"
    ) &
    spinner $! "Création du snapshot"
    
    local metadata_file="${env_snapshots_dir}/snapshots.json"
    local snapshot_size=$(du -h "$snapshot_file" | cut -f1)
    local snapshot_date=$(date -Iseconds)
    
    if [ ! -f "$metadata_file" ]; then
        echo "[]" > "$metadata_file"
    fi
    
    if command -v jq >/dev/null 2>&1; then
        jq ". += [{\"name\": \"$snapshot_name\", \"date\": \"$snapshot_date\", \"size\": \"$snapshot_size\"}]" "$metadata_file" > "${metadata_file}.tmp" && mv "${metadata_file}.tmp" "$metadata_file"
    else
        echo "  {\"name\": \"$snapshot_name\", \"date\": \"$snapshot_date\", \"size\": \"$snapshot_size\"}" >> "$metadata_file.simple"
    fi
    
    echo -e "${GREEN}[*] Snapshot '${snapshot_name}' créé (${snapshot_size})${NC}"
}

list_snapshots() {
    local envname="$1"
    local env_snapshots_dir="${SNAPSHOTS_DIR}/${envname}"
    
    if [ ! -d "${ARCHSHELL_ENVS}/${envname}" ]; then
        echo -e "${RED}[!] Environnement inexistant : ${envname}${NC}"
        exit 3
    fi
    
    if [ ! -d "$env_snapshots_dir" ] || [ -z "$(ls -A "$env_snapshots_dir"/*.tar.{zst,xz} 2>/dev/null)" ]; then
        echo -e "${YELLOW}[*] Aucun snapshot trouvé pour l'environnement ${envname}${NC}"
        return
    fi
    
    echo -e "${BLUE}[*] Snapshots pour l'environnement '${envname}':${NC}"
    
    local i=1
    for snapshot_file in "$env_snapshots_dir"/*.tar.{zst,xz}; do
        if [ -f "$snapshot_file" ]; then
            local snapshot_name=$(basename "$snapshot_file")
            snapshot_name=${snapshot_name%.tar.*}
            local snapshot_size=$(du -h "$snapshot_file" | cut -f1)
            local snapshot_date=$(stat -c %y "$snapshot_file" | cut -d. -f1)
            local format=""
            if [[ "$snapshot_file" == *.tar.zst ]]; then
                format=" (zstd)"
            else
                format=" (legacy xz)"
            fi
            
            echo -e "  ${GREEN}${i}.${NC} ${snapshot_name} - ${snapshot_size} (${snapshot_date})${format}"
            ((i++))
        fi
    done
}

restore_snapshot() {
    local envname="$1"
    local snapshot_name="$2"
    local envdir="${ARCHSHELL_ENVS}/${envname}"
    local env_snapshots_dir="${SNAPSHOTS_DIR}/${envname}"
    
    if [ ! -d "$envdir" ]; then
        echo -e "${RED}[!] Environnement inexistant : ${envname}${NC}"
        exit 3
    fi
    
    local snapshot_file
    if [[ "$snapshot_name" =~ ^[0-9]+$ ]]; then
        local i=1
        for file in "$env_snapshots_dir"/*.tar.{zst,xz}; do
            if [ -f "$file" ] && [ "$i" -eq "$snapshot_name" ]; then
                snapshot_file="$file"
                break
            fi
            ((i++))
        done
    else
        if [ -f "${env_snapshots_dir}/${snapshot_name}.tar.zst" ]; then
            snapshot_file="${env_snapshots_dir}/${snapshot_name}.tar.zst"
        elif [ -f "${env_snapshots_dir}/${snapshot_name}.tar.xz" ]; then
            snapshot_file="${env_snapshots_dir}/${snapshot_name}.tar.xz"
        else
            snapshot_file="${env_snapshots_dir}/${snapshot_name}.tar.zst"
        fi
    fi
    
    if [ ! -f "$snapshot_file" ]; then
        echo -e "${RED}[!] Snapshot '${snapshot_name}' introuvable${NC}"
        exit 5
    fi
    
    echo -e "${YELLOW}[!] ATTENTION: Cette opération va remplacer l'environnement actuel${NC}"
    if ! ask_confirmation "Continuer ? [o/N] "; then
        echo "Annulé."
        exit 0
    fi
    
    echo -e "${BLUE}[*] Restauration du snapshot pour ${envname}...${NC}"
    
    local backup_name="backup-avant-restore-$(date +%Y%m%d%H%M%S)"
    mv "$envdir" "${envdir}.${backup_name}"
    
    (
        cd "${ARCHSHELL_ENVS}" && \
        if [[ "$snapshot_file" == *.tar.zst ]]; then
            debug_run "tar --zstd -xf '$snapshot_file'"
        else
            debug_run "tar -xJf '$snapshot_file'"
        fi
    ) &
    if [[ "$snapshot_file" == *.tar.zst ]]; then
        spinner $! "Restauration du snapshot (zstd)"
    else
        spinner $! "Restauration du snapshot (legacy xz)"
    fi
    
    if [ -d "$envdir" ]; then
        sudo rm -rf "${envdir}.${backup_name}"
        echo -e "${GREEN}[*] Snapshot restauré avec succès${NC}"
    else
        mv "${envdir}.${backup_name}" "$envdir"
        echo -e "${RED}[!] Échec de la restauration, environnement restauré${NC}"
        exit 6
    fi
}

delete_snapshot() {
    local envname="$1"
    local snapshot_name="$2"
    local env_snapshots_dir="${SNAPSHOTS_DIR}/${envname}"
    local snapshot_file="${env_snapshots_dir}/${snapshot_name}.tar.zst"
    
    if [ ! -d "${ARCHSHELL_ENVS}/${envname}" ]; then
        echo -e "${RED}[!] Environnement inexistant : ${envname}${NC}"
        exit 3
    fi
    
    if [ ! -f "$snapshot_file" ]; then
        echo -e "${RED}[!] Snapshot '${snapshot_name}' introuvable${NC}"
        exit 5
    fi
    
    if ask_confirmation "Supprimer définitivement le snapshot '${snapshot_name}' ? [o/N] "; then
        rm -f "$snapshot_file"
        
        local metadata_file="${env_snapshots_dir}/snapshots.json"
        if [ -f "$metadata_file" ] && command -v jq >/dev/null 2>&1; then
            jq "map(select(.name != \"$snapshot_name\"))" "$metadata_file" > "${metadata_file}.tmp" && mv "${metadata_file}.tmp" "$metadata_file"
        fi
        
        echo -e "${GREEN}[*] Snapshot '${snapshot_name}' supprimé${NC}"
    else
        echo "Annulé."
    fi
}

while [ $# -gt 0 ]; do
    case "$1" in
        --debug)
            DEBUG=true
            shift
            debug_log "Mode debug activé"
            ;;
        --no-color)
            NO_COLOR=true
            shift
            debug_log "Mode sans couleur activé"
            ;;
        --yes)
            YES=true
            shift
            debug_log "Mode automatique activé"
            ;;
        --quiet)
            QUIET=true
            shift
            debug_log "Mode silencieux activé"
            ;;
        *)
            break
            ;;
    esac
done

init_colors

if [ $# -lt 1 ]; then
    usage
fi

case "$1" in
  init)
    mkdir -p "$ARCHSHELL_STORE"
    init_shared_cache
    if [ -d "$BASE_TEMPLATE" ]; then
      echo "Template de base existe déjà. Utilisez 'regen-base' pour le régénérer."
    else
      echo -e "${BLUE}[*] Création du template de base...${NC}"
      (
        debug_run "sudo mkarchroot '$BASE_TEMPLATE' base"
      ) &
      spinner $! "Création du template de base"
      echo -e "${GREEN}[*] Template de base créé.${NC}"
    fi
    ;;
  regen-base)
    mkdir -p "$ARCHSHELL_STORE"
    init_shared_cache
    echo -e "${BLUE}[*] Régénération du template de base...${NC}"
    if [ -d "$BASE_TEMPLATE" ]; then
      debug_run "sudo rm -rf '$BASE_TEMPLATE'"
    fi
    (
      debug_run "sudo mkarchroot '$BASE_TEMPLATE' base"
    ) &
    spinner $! "Régénération du template de base"
    echo -e "${GREEN}[*] Template de base régénéré.${NC}"
    ;;
  create)
    if [ $# -lt 2 ]; then
      echo "Usage: $0 create <env>"
      exit 1
    fi
    ENVNAME="$2"
    if [ ! -d "$BASE_TEMPLATE" ]; then
      echo "Template de base introuvable. Exécutez d'abord '$0 init'."
      exit 2
    fi
    if [ -d "${ARCHSHELL_ENVS}/${ENVNAME}" ]; then
      echo "L'environnement ${ENVNAME} existe déjà."; exit 5;
    fi
    echo -e "${BLUE}[*] Création de l'environnement $ENVNAME à partir du template...${NC}"
    mkdir -p "${ARCHSHELL_ENVS}/${ENVNAME}"
    total=$(sudo du -sb "$BASE_TEMPLATE" | awk '{print $1}')
    (
      debug_run "sudo rsync -a --info=progress2 '$BASE_TEMPLATE/' '${ARCHSHELL_ENVS}/${ENVNAME}/'"
    ) &
    spinner $! "Copie du template"
    sudo chown -R $USER: "${ARCHSHELL_ENVS}/${ENVNAME}"
    update_env_info "$ENVNAME"
    echo -e "${GREEN}[*] Environnement $ENVNAME créé.${NC}"
    ;;
  -S)
    if [ $# -lt 3 ]; then
      echo "Usage: $0 -S <env> <pkg...>"
      exit 1
    fi
    ENVNAME="$2"
    shift 2
    if [ ! -d "${ARCHSHELL_ENVS}/${ENVNAME}" ]; then
      echo "Environnement inexistant : ${ENVNAME}"; exit 3;
    fi
    init_shared_cache
    cache_hits=0
    total_packages=$#
    for pkg in "$@"; do
        if track_cache_hit "$pkg"; then
            cache_hits=$((cache_hits + 1))
        fi
    done
    new_downloads=$((total_packages - cache_hits))
    
    echo -e "${BLUE}[*] Installation de(s) paquet(s) $* dans $ENVNAME...${NC}"
    (
      debug_run "sudo arch-nspawn -c '$SHARED_CACHE/pkg' '${ARCHSHELL_ENVS}/${ENVNAME}' pacman -S --noconfirm $*"
    ) &
    install_pid=$!
    spinner $install_pid "Installation des paquets"
    wait $install_pid
    install_result=$?
    
    if [ $install_result -eq 0 ]; then
      echo -e "${GREEN}[*] Installation terminée.${NC}"
      update_last_used "$ENVNAME"
      for pkg in "$@"; do
        add_package "$ENVNAME" "$pkg"
      done
      if [ $new_downloads -gt 0 ]; then
        track_download $new_downloads
      fi
      update_cache_stats
    else
      echo -e "${RED}[!] Installation échouée (code: $install_result)${NC}"
      exit $install_result
    fi
    ;;
  -R)
    if [ $# -lt 3 ]; then
      echo "Usage: $0 -R <env> <pkg...>"
      exit 1
    fi
    ENVNAME="$2"
    shift 2
    if [ ! -d "${ARCHSHELL_ENVS}/${ENVNAME}" ]; then
      echo "Environnement inexistant : ${ENVNAME}"; exit 3;
    fi
    init_shared_cache
    
    missing_packages=()
    for pkg in "$@"; do
      if ! check_package_in_env "$ENVNAME" "$pkg"; then
        missing_packages+=("$pkg")
      fi
    done
    
    if [ ${#missing_packages[@]} -gt 0 ]; then
      echo -e "${RED}[!] Les paquets suivants ne sont pas installés dans l'environnement ${ENVNAME} :${NC}"
      for pkg in "${missing_packages[@]}"; do
        echo "  - $pkg"
      done
      echo -e "${YELLOW}[!] Seuls les paquets présents dans .arch-shell-env peuvent être supprimés.${NC}"
      exit 4
    fi
    
    echo -e "${BLUE}[*] Suppression de(s) paquet(s) $* dans $ENVNAME...${NC}"
    (
      debug_run "sudo arch-nspawn -c '$SHARED_CACHE/pkg' '${ARCHSHELL_ENVS}/${ENVNAME}' pacman -R --noconfirm $*"
    ) &
    remove_pid=$!
    spinner $remove_pid "Suppression des paquets"
    wait $remove_pid
    remove_result=$?
    
    if [ $remove_result -eq 0 ]; then
      echo -e "${GREEN}[*] Suppression terminée.${NC}"
      update_last_used "$ENVNAME"
      for pkg in "$@"; do
        remove_package "$ENVNAME" "$pkg"
      done
    else
      echo -e "${RED}[!] Suppression échouée (code: $remove_result)${NC}"
      exit $remove_result
    fi
    ;;
  enter)
    if [ $# -lt 2 ]; then
      echo "Usage: $0 enter <env>"
      exit 1
    fi
    ENVNAME="$2"
    if [ ! -d "${ARCHSHELL_ENVS}/${ENVNAME}" ]; then
      echo "Environnement inexistant : ${ENVNAME}"; exit 3;
    fi
    init_shared_cache
    echo "Entrée dans l'environnement $ENVNAME."
    update_last_used "$ENVNAME"
    sudo arch-nspawn -c "$SHARED_CACHE/pkg" "${ARCHSHELL_ENVS}/${ENVNAME}"
    ;;
  delete)
    if [ $# -lt 2 ]; then
      echo "Usage: $0 delete <env>"
      exit 1
    fi
    ENVNAME="$2"
    if [ ! -d "${ARCHSHELL_ENVS}/${ENVNAME}" ]; then
      echo "Environnement inexistant : ${ENVNAME}"; exit 3;
    fi
    if ask_confirmation "Supprimer définitivement ${ENVNAME} ? [o/N] "; then
      sudo rm -rf "${ARCHSHELL_ENVS}/${ENVNAME}"
      LOCKFILE="${ARCHSHELL_ENVS}/${ENVNAME}.lock"
      if [ -f "$LOCKFILE" ]; then
        sudo rm -f "$LOCKFILE"
      fi
      echo "Environnement supprimé."
    else
      echo "Annulé."
    fi
    ;;
  list)
    echo "Environnements disponibles :"
    for env in "$ARCHSHELL_ENVS"/*; do
      [ -d "$env" ] || continue
      [ "$(basename "$env")" = "store" ] && continue
      if [ -f "$env/.arch-shell-env" ]; then
        echo "- $(basename "$env")"
      fi
    done
    ;;
  info)
    if [ $# -lt 2 ]; then
      echo "Usage: $0 info <env>"
      exit 1
    fi
    ENVNAME="$2"
    INFOFILE="${ARCHSHELL_ENVS}/${ENVNAME}/.arch-shell-env"
    if [ ! -f "$INFOFILE" ]; then
      echo "Environnement inexistant : ${ENVNAME}"; exit 3;
    fi
    echo "Informations sur l'environnement $ENVNAME :"
    if command -v jq >/dev/null 2>&1; then
      jq '.' "$INFOFILE"
    else
      cat "$INFOFILE"
    fi
    ;;
  export)
    if [ $# -lt 3 ]; then
      echo "Usage: $0 export <env> <file>"
      exit 1
    fi
    ENVNAME="$2"
    EXPORT_FILE="$3"
    export_env "$ENVNAME" "$EXPORT_FILE"
    ;;
  import)
    if [ $# -lt 3 ]; then
      echo "Usage: $0 import <file> <env>"
      exit 1
    fi
    IMPORT_FILE="$2"
    ENVNAME="$3"
    import_env "$IMPORT_FILE" "$ENVNAME"
    ;;
  run)
    if [ $# -lt 2 ]; then
      usage_run
    fi
    ENVNAME="$2"
    shift 2
    run_command "$ENVNAME" "$@"
    ;;
  clean)
    if [ $# -lt 1 ]; then
      usage_clean
    fi
    if [ $# -ge 2 ] && [ "$2" = "--all-envs" ]; then
      shift 1
      clean_env "" "$@"
    else
      if [ $# -lt 2 ]; then
        usage_clean
      fi
      ENVNAME="$2"
      shift 2
      clean_env "$ENVNAME" "$@"
    fi
    ;;
  snapshot)
    if [ $# -lt 2 ]; then
      usage_snapshot
    fi
    
    if [ $# -ge 3 ] && [ "$3" = "--list" ]; then
      list_snapshots "$2"
    elif [ $# -ge 3 ] && [ "$3" = "--restore" ]; then
      if [ $# -lt 4 ]; then
        echo "Usage: $0 snapshot <env> --restore <snapshot>"
        exit 1
      fi
      restore_snapshot "$2" "$4"
    elif [ $# -ge 3 ] && [ "$3" = "--delete" ]; then
      if [ $# -lt 4 ]; then
        echo "Usage: $0 snapshot <env> --delete <snapshot>"
        exit 1
      fi
      delete_snapshot "$2" "$4"
    else
      create_snapshot "$2" "${3:-}"
    fi
    ;;
  cache)
    case "${2:-}" in
      --stats)
        init_shared_cache
        show_cache_stats
        ;;
      --clean)
        init_shared_cache
        days_old="${3:-30}"
        echo -e "${BLUE}[*] Nettoyage du cache partagé (paquets > ${days_old} jours)...${NC}"
        before_count=$(find "$SHARED_CACHE/pkg" -name "*.pkg.tar.*" 2>/dev/null | wc -l || echo "0")
        before_size=$(du -sb "$SHARED_CACHE/pkg" 2>/dev/null | awk '{print $1}' || echo "0")
        
        find "$SHARED_CACHE/pkg" -name "*.pkg.tar.*" -mtime +$days_old -delete 2>/dev/null
        
        after_count=$(find "$SHARED_CACHE/pkg" -name "*.pkg.tar.*" 2>/dev/null | wc -l || echo "0")
        after_size=$(du -sb "$SHARED_CACHE/pkg" 2>/dev/null | awk '{print $1}' || echo "0")
        freed=$((before_size - after_size))
        removed=$((before_count - after_count))
        
        echo -e "${GREEN}[*] Cache nettoyé : ${removed} paquets supprimés ($(numfmt --to=iec $freed) libérés)${NC}"
        update_cache_stats
        ;;
      *)
        echo "Usage: $0 cache --stats|--clean [jours]"
        exit 1
        ;;
    esac
    ;;
  *)
    usage
    ;;
esac